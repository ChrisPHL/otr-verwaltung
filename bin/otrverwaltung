#!/usr/bin/env python
# -*- coding: utf-8 -*-
### BEGIN LICENSE
# Copyright (C) 2010 Benjamin Elbers <elbersb@gmail.com>
#This program is free software: you can redistribute it and/or modify it 
#under the terms of the GNU General Public License version 3, as published 
#by the Free Software Foundation.
#
#This program is distributed in the hope that it will be useful, but 
#WITHOUT ANY WARRANTY; without even the implied warranties of 
#MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
#PURPOSE.  See the GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License along 
#with this program.  If not, see <http://www.gnu.org/licenses/>.
### END LICENSE

import sys
import os
from os.path import join, isdir, exists
import re
import subprocess
import time
import hashlib
import optparse
import logging

try:
    from gtk import events_pending, main_iteration
    from gtk import gdk
    import gobject
    gdk.threads_init()    
except:
    print "PyGTK/GTK is missing."
    sys.exit(-1)

# Options and configuration
def parse_opts():
    usage = "usage: %prog [options]"

    oparse = optparse.OptionParser(usage=usage)

    oparse.add_option("-v", "--verbose", action="store_true",
                      help="Verbose messages", default=False)
    oparse.add_option("-d", "--debug", action="store_true",
                      help="Debug messages", default=False)

    opts, rest = oparse.parse_args()
    return opts
    
opts = parse_opts()

if opts.debug:
    logging.root.setLevel(logging.DEBUG)
elif opts.verbose:
    logging.root.setLevel(logging.INFO)

# Setup path

launch_dir = os.path.abspath(sys.path[0])
source_tree = os.path.join(launch_dir, "..", "otrverwaltung")

# If we were invoked from source directory add that as the
# preferred module path ...
if os.path.exists(os.path.join(source_tree, "path.py")):        
    local = True
    logging.info("Running from source tree; adjusting path")
    sys.path.insert(0, os.path.realpath(os.path.dirname(source_tree)))
    locale_dir = os.path.join(launch_dir, "..", "locale")
else:
    local = False
    logging.debug("Assuming path is correct")
    locale_dir = "/usr/share/locale"
    
    try:
        import otrverwaltung
    except ImportError: # possible on systems where pycentral is not installed
        sys.path.insert(0, "/usr/share/pyshared")           
    
import gettext, locale
import gtk.glade
gettext.install('otrverwaltung', locale_dir, True)
    
locale.setlocale(locale.LC_ALL, '')
for module in gettext, gtk.glade:
     module.bindtextdomain('otrverwaltung', locale_dir)
     module.textdomain('otrverwaltung')    
    
# intern
from otrverwaltung.gui import gui
from otrverwaltung.pluginsystem import PluginSystem
from otrverwaltung.actions import actions
from otrverwaltung.config import Config
from otrverwaltung import fileoperations
import otrverwaltung.cutlists as cutlists_management
from otrverwaltung.constants import Section, Action, Cut_action
from otrverwaltung.planning import Planning
from otrverwaltung import path

class App:
    """ Hauptklasse des Programms. """
    
    section = Section.OTRKEY
    """ Die aktuell angezeigt `~constants.Section`. Zum Ã„ndern sollte die Funktion `~otr.App.show_section` verwendet werden. """
    
    def __init__(self):        
   
        configuration = {
            'general': {
                'folder_new_otrkeys': '',
                'folder_uncut_avis': '',
                'folder_cut_avis': '',
                'folder_trash_otrkeys': '',
                'folder_trash_avis': '',
                'folder_archive': '',
                'decoder': '',
                'save_email_password': False,
                'email': '',
                'password': '',
                'verify_decoded': False,
                'cut_avis_by': 'avidemux',
                'cut_hqs_by':           '',
                'cut_mp4s_by': 'avidemux',
                'cut_avis_man_by': 'avidemux',
                'cut_hqs_man_by': '',
                'cut_mp4s_man_by': 'avidemux',
                'server': 'http://cutlist.at/',
                'cut_action': Cut_action.ASK,
                'delete_cutlists': True,
                'smart': True,
                'choose_cutlists_by': 0, # 0 = size, 1=name
                'cutlist_username': '',
                'mplayer': 'mplayer',
                'planned_items': '',
                'rename_cut': True,
                'rename_schema': '{titel} vom {tag}. {MONAT} {jahr}, {stunde}-{minute} ({sender})',
                'cutlist_mp4_as_hq': False, # for mp4s, when searching cutlist by name, add an HQ --> Name.HQ.mp4
                'show_bottom': False,                
                'cutlist_hash': hashlib.md5(str(time.time())).hexdigest(),
                'window_settings': '',
                'pre_cut_show': 11,
                'after_cut_show': 5
            },
            'plugins': {
                'enabled': 'Play',
                'config': {} # used as plugin config storage
            }
                         
        }
        
        if local:
            self.config = Config(os.path.join(launch_dir, "..", "conf"), configuration)    
        else:
            # TODO: Remove this line after one release
            configuration = self.import_old_config(configuration)
                    
            self.config = Config(path.get_config_dir("conf"), configuration)

        self.__search_text = ""
        self.locked = False
            
        # regex
        self.uncut_video = re.compile('.*_([0-9]{2}\.){2}([0-9]){2}_([0-9]){2}-([0-9]){2}_.*_([0-9])*_TVOON_DE.mpg\.(avi|HQ\.avi|HD\.avi|mp4)$')
        self.cut_video = re.compile('.*(avi|mp4|mkv|wmv)$')
       
        # load gui
        self.__gui = gui.Gui(self)    

        self.config.load()
    
        if self.config.get('general', 'window_settings'):
            maximize, width, height = self.config.get('general', 'window_settings').split(',')
            if int(maximize):
                self.__gui.main_window.maximize()            
            self.__gui.main_window.resize(int(width), int(height))
    
        # load plugins
        if local:
            plugin_paths = [path.getdatapath('plugins')]
        else:
            plugin_paths = path.get_plugin_paths()
    
        self.plugin_system = PluginSystem(self, self.__gui, plugin_paths, self.config.get('plugins', 'enabled'), self.config.get('plugins', 'config'))
    
        # show undecoded otrkeys         
        self.show_section(Section.OTRKEY)
        
        self.planned_broadcasts = Planning()
        self.planned_broadcasts.read_config(self.config.get('general', 'planned_items'))
        
        self.__gui.main_window.broadcasts_badge()                           
       
    def import_old_config(self, configuration):
        # TODO: Remove after one release          
        
        # try to move plugins
        import shutil
        src = join(os.environ.get('HOME'), '.otr-verwaltung', 'plugins')
        dst = path.get_storage_dir("plugins")
        try:
            shutil.copytree(src, dst)                    
        except:
            pass
        
        try:
            config = join(os.environ.get('HOME'), '.otr-verwaltung', 'conf')            
            config = open(config, 'r')
        except:
            return configuration
                       
        # read file
        for line in config:
            if not '=' in line:
                continue
            key, value = line.split('=', 1)
            key, value = key.strip(), value.strip()
            
            if key in configuration['general'].keys():
                datatype = type(configuration['general'][key])
                
                #print "%5s: %15s=%15s" % (datatype, key.strip(), value)
                if datatype == bool:
                    value = bool(int(value))
                else:
                    value = datatype(value)
                
                print "IMPORT: %s of %s" % (key, datatype)
                configuration['general'][key] = value

            elif key=="enabled_plugins":
                configuration['plugins']['enabled'] = value      
                
        os.rename(join(os.environ.get('HOME'), '.otr-verwaltung'), join(os.environ.get('HOME'), '.otr-verwaltung_ALT'))
           
        return configuration 
             
    ### 
    ### Show sections
    ###
    
    def show_section(self, section):
        """ Zeigt eine der verschiedenen `Sections <constants.Section>` an. 
                        
            * aktualisiert einen Treeview und zeigt den korrekten an
            * setzt die aktuelle `~otr.App.section`
            * zeigt die korrekten Toolbuttons an """

        # set current section
        self.section = section
        
        # set toolbar
        self.__gui.main_window.set_toolbar(section)
                
        self.__gui.main_window.clear_files()
        files = []
        text = ""
        
        if section == Section.PLANNING:
            text = self.__section_planning()
      
            self.__gui.main_window.show_planning(True)
        else:
            self.__gui.main_window.show_planning(False)
        
        if section == Section.OTRKEY:
            text, files = self.__section_otrkey()
        
        elif section == Section.VIDEO_UNCUT:
            text, files = self.__section_video_uncut()   

        elif section == Section.VIDEO_CUT:
            text, files = self.__section_video_cut()   

        elif section == Section.TRASH:
            text, files = self.__section_trash()   

        elif section == Section.ARCHIVE: 
            # returns NO files       
            text = self.__section_archive()

        if len(files) > 0: # this is not executed when the section is "Archive"
            if len(files) == 1:
                text += " (1 Datei)"
            else:
                text += " (%s Dateien) " % len(files)
            
            files.sort() 
            
            # put filenames into treestore
            for f in files:
                # TODO: don't show files if in use
                self.__append_row_treeview_files(None, f)

        # set message text
        self.__gui.main_window.builder.get_object('labelMessage').set_markup(text)


    # helper for different sections
    def __section_planning(self):
        text = "Diese Aufnahmen wurden geplant." 
       
        for count, broadcast in enumerate(self.planned_broadcasts):
            if self.search(broadcast.title):
                self.__gui.main_window.append_row_planning(self.planned_broadcasts[count])
            
        return text
             
    def __section_otrkey(self):
        text = "Diese Dateien wurden noch nicht dekodiert." 
        path = self.config.get('general', 'folder_new_otrkeys')
        
        if path == "":
            return text, []
        
        files = [join(path, f) for f in os.listdir(path) if f.endswith(".otrkey") and self.search(f)]                           
            
        return (text, files)
         
    def __section_video_uncut(self):
        text = "Diese Dateien wurden noch nicht geschnitten."
        path = self.config.get('general', 'folder_uncut_avis')
        
        files = [join(path, f) for f in os.listdir(path) if self.uncut_video.match(f) and self.search(f)]
            
        return (text, files)
        
    def __section_video_cut(self):
        text = "Diese Video-Dateien sind fertig geschnitten. Sie kÃ¶nnen ins Archiv verschoben werden."
                
        path = self.config.get('general', 'folder_cut_avis')
        
        files = []                
        for f in os.listdir(path):
            if not self.uncut_video.match(f):
                if self.cut_video.match(f):
                    if self.search(f):
                        files += [join(path, f)]
        
        return (text, files)
        
    def __section_trash(self):
        text = "Diese otrkey- und Video-Dateien wurden bereits dekodiert bzw. geschnitten. Sie kÃ¶nnen normalerweise gelÃ¶scht werden."
        path_otrkeys = self.config.get('general', 'folder_trash_otrkeys')
        path_avis = self.config.get('general', 'folder_trash_avis')
                    
        files = [join(path_otrkeys, f) for f in os.listdir(path_otrkeys) if f.endswith('.otrkey') and self.search(f)]
        files += [join(path_avis, f) for f in os.listdir(path_avis) if self.cut_video.match(f) and self.search(f)]
                
        return (text, files)

    def __section_archive(self):
        text = "Diese Dateien wurden ins Archiv verschoben."

        path = self.config.get('general', 'folder_archive')
        
        self.__tree(None, path)        
        
        return text            
                 
    # recursive function for archive to add folders and files with a tree structure
    def __tree(self, parent=None, path=None):              
        if parent != None:            
            dir = self.__gui.main_window.builder.get_object('treeview_files').get_model().get_value(parent, 0)
        else:  # base path (archive directory)
            dir = path

        files = []
        files = os.listdir(dir)            

        for file in files:
            full_path = join(dir, file)
            
            if isdir(full_path):                
                iter = self.__append_row_treeview_files(parent, full_path)
                self.__tree(iter)
            else:
                if self.cut_video.match(file):
                    if self.search(file):
                        self.__append_row_treeview_files(parent, full_path)

    ###
    ### Helpers
    ###
    
    def rename_by_schema(self, filename, schema=""):
        """ Gibt den nach dem angegebenen Schema umbenannten Dateinamen zurÃ¼ck. Wird `schema` leer gelassen, so wird das eingestellte Schema verwendet. """
    
        if schema == "":
            schema = self.config.get('general', 'rename_schema')        
        
        if self.uncut_video.match(filename):           
            
            parts = filename.split('_')
            parts.reverse()

            titel_list = parts[6:len(parts)]
            titel_list.reverse()
            titel = " ".join(titel_list)
            titel_mit = "_".join(titel_list)
            titel_dot = ".".join(titel_list)

            stunde, minute = parts[4].split('-')
            jahr, monat, tag = parts[5].split('.')           
            monatsname = time.strptime(monat, '%m')
            monatsname = time.strftime('%B', monatsname)

            sender_gross = parts[3].capitalize()

            format = parts[0]
            
            if 'mp4' in format:
                format = 'mp4'
            elif 'HQ' in format:
                format = 'HQ'
            elif 'HD' in format:
                format = 'HD'
            else:
                format = 'avi'

            values = {
                'titel' : titel,
                'titel_' : titel_mit,
                'titel.' : titel_dot,
                'sender' : parts[3],
                'SENDER': sender_gross,
                'tag': tag,
                'monat': monat,
                'MONAT': monatsname,
                'jahr': jahr,
                'stunde': stunde,
                'minute': minute,
                'dauer' : parts[2],
                'format' : format
            }
             
            for token, value in values.iteritems():
                schema = schema.replace('{%s}' % token, value)                            
                
            return schema
        else:         
            return filename
     
    def __append_row_treeview_files(self, parent, filename):        
        iter = self.__gui.main_window.append_row_files(parent, filename, fileoperations.get_size(filename), fileoperations.get_date(filename), isdir(filename))
        return iter
     
    
    ### 
    ### Search
    ### 
                      
    def start_search(self, search):
        """ #FIXME """

        self.__search_text = search.lower()

        items = []        
        # create dict of counts
        counts = {}

        for method, section in [(self.__section_otrkey, Section.OTRKEY),
                                (self.__section_video_uncut, Section.VIDEO_UNCUT),
                                (self.__section_video_cut, Section.VIDEO_CUT),
                                (self.__section_trash, Section.TRASH)]:
            files = []
            text, items = method()   
            count = len(items)
            if count > 0:
                counts[section] = "(%s)" % count
            else:
                counts[section] = ""
         
        # archive 
        files = []       
        for root, dirs, wfiles in os.walk(self.config.get('general', 'folder_archive')):
            for f in wfiles:                
                if self.cut_video.match(f) and self.search(f):
                    files += [join(root, f)]

        count = len(files)
        if count > 0:
            counts[Section.ARCHIVE] = "(%s)" % count
        else:
            counts[Section.ARCHIVE] = ""

        # planning
        items = []
        for count, broadcast in enumerate(self.planned_broadcasts):
            if self.search(broadcast.title):
                items += [count]

        count = len(items)
        if count > 0:
            counts[Section.PLANNING] = "(%s)" % count
        else:
            counts[Section.PLANNING] = ""
        
        self.show_section(self.section)                   
        
        return counts
    
    def stop_search(self):
        """ #FIXME """
        
        self.__search_text = ""
        self.show_section(self.section)
        
    def search(self, f):
        """ #FIXME """
        
        if self.__search_text == "":
            return True
        else:    
            if self.__search_text in f.lower():
                return True
            else:
                return False
        
    ###
    ### Actions
    ###        
    
    def perform_action(self, chosen_action, filenames=None, broadcasts=None, cut_action=None):
        """ #FIXME """
       
        if broadcasts != None and chosen_action in [Action.PLAN_EDIT, Action.PLAN_SEARCH, Action.PLAN_REMOVE, Action.PLAN_ADD, Action.PLAN_RSS]:
            if len(broadcasts) == 0 and not chosen_action in [Action.PLAN_ADD, Action.PLAN_RSS]:
                if len(self.__gui.main_window.builder.get_object('treeview_planning').get_model()) > 0:
                    if self.__gui.question_box("Es ist keine Sendung markiert! Sollen alle Sendungen verarbeitet werden?"):
                        broadcasts = []                    

                        def foreach(model, path, iter, broadcasts):
                            broadcasts += [iter]

                        self.__gui.main_window.builder.get_object('treeview_planning').get_model().foreach(foreach, broadcasts)
                    else:
                        return
                else:
                    return

        elif filenames != None:
            if len(filenames) == 0 and chosen_action != Action.NEW_FOLDER:
                if len(self.__gui.main_window.builder.get_object('treeview_files').get_model()) > 0:
                    if self.__gui.question_box("Es ist keine Datei markiert! Sollen alle Dateien verarbeitet werden?"):
                        filenames = [row[0] for row in self.__gui.main_window.builder.get_object('treeview_files').get_model()]
                    else:
                        return
                else:
                    return          

        action = actions.get_action(chosen_action, self.__gui)

        self.locked = True
               
        # different actions:
        if chosen_action in [Action.DECODE, Action.CUT, Action.DECODEANDCUT]:             
            action.do(chosen_action, filenames, self.config, self.rename_by_schema, cut_action)
    
        elif chosen_action == Action.RENAME: 
            action.do(filenames)
    
        elif chosen_action == Action.REAL_DELETE: 
            action.do(filenames)
    
        elif chosen_action == Action.RESTORE: 
            action.do(filenames, self.config.get('general', 'folder_new_otrkeys'), self.config.get('general', 'folder_uncut_avis'), self.config.get('general', 'folder_cut_avis'), self.uncut_video)
    
        elif chosen_action == Action.DELETE:
            action.do(filenames, self.config.get('general', 'folder_trash_otrkeys'), self.config.get('general', 'folder_trash_avis'))      

        elif chosen_action == Action.PLAN_REMOVE: 
            action.do(broadcasts, self.planned_broadcasts) 
    
        elif chosen_action == Action.PLAN_SEARCH: 
            action.do(broadcasts, self.planned_broadcasts)            
    
        elif chosen_action == Action.PLAN_ADD: 
            action.do(self.planned_broadcasts)
    
        elif chosen_action == Action.PLAN_EDIT: 
            action.do(broadcasts[0], self.planned_broadcasts)       
            
        elif chosen_action == Action.PLAN_RSS:
            action.do(self.planned_broadcasts, self.config.get('general', 'email'), self.config.get('general', 'password')) 
    
        elif chosen_action == Action.ARCHIVE: 
            action.do(filenames, self.config.get('general', 'folder_archive'))
     
        elif chosen_action == Action.NEW_FOLDER:
            if len(filenames) == 0:
                action.do(self.config.get('general', 'folder_archive'))
            else:
                action.do(filenames[0])
        
        self.locked = False
        
        # update view?
        if action.update_list:            
            self.__gui.main_window.do_search(self.__search_text)
            self.show_section(self.section)
            
    
    def play_file(self, filename):
        """ #FIXME """        
        
        subprocess.Popen(['xdg-open', filename])
    
    def __show(self, cuts, video_filename, edl_subtitles_cb):        
        f_edl = open(join(self.config.get('general', 'folder_new_otrkeys'), ".tmp.edl"), "w")
        f_sub = open(join(self.config.get('general', 'folder_new_otrkeys'), ".tmp.sub"), "w")    
        
        # get cuts in seconds
        
        edl_subtitles_cb(f_edl, f_sub, cuts)        
        
        f_edl.close()
        f_sub.close()
        
        f_edl = join(self.config.get('general', 'folder_new_otrkeys'), ".tmp.edl")
        f_sub = join(self.config.get('general', 'folder_new_otrkeys'), ".tmp.sub")
            
        p = subprocess.Popen([self.config.get('general', 'mplayer'), "-osdlevel", "3", "-edl", f_edl, "-sub", f_sub, video_filename])
       
        # wait
        while p.poll() == None:
            time.sleep(1)
            while events_pending():
                main_iteration(False)
                
        fileoperations.remove_file(f_edl)
        fileoperations.remove_file(f_sub)
        
    def show_cuts(self, video_filename, cutlist):
        """ #FIXME """
        
        def edl_subtitles_cb(f_edl, f_sub, cuts):            
            diff = self.config.get('general', 'pre_cut_show')
            pre_diff = self.config.get('general', 'after_cut_show')
            
            sub_count = 0

            f_edl.write("0 ")      

            for count, (start, duration) in enumerate(cuts):
                end = start + duration

                f_edl.write("%s 0\n" % (start - diff))
                f_edl.write("%s %s 0\n" % (start + pre_diff, end - diff))
                f_edl.write("%s " % (end + pre_diff))

                if count == 0:
                    for second in range(diff):
                        sub_count += 1
                        f_sub.write("%s\n" % sub_count)
                        f_sub.write("%s --> %s\n" % (self.format_seconds(start-diff+second), self.format_seconds(start-diff+second+1)))
                        f_sub.write("Sendung beginnt in %s Sekunden...\n\n" % str(diff - second))
                else:
                    for second in range(diff):
                        sub_count += 1
                        f_sub.write("%s\n" % sub_count)
                        f_sub.write("%s --> %s\n" % (self.format_seconds(start-diff+second), self.format_seconds(start-diff+second+1)))
                        f_sub.write("Werbung #%i endet in %s Sekunden...\n\n" % (count, str(diff - second)))

                if count == (len(cuts) - 1):
                    for second in range(diff):
                        sub_count += 1
                        f_sub.write("%s\n" % sub_count)
                        f_sub.write("%s --> %s\n" % (self.format_seconds(end-diff+second), self.format_seconds(end-diff+second+1)))
                        f_sub.write("Sendung endet in %s Sekunden...\n\n" % str(diff - second))
                else:
                    for second in range(diff):
                        sub_count += 1
                        f_sub.write("%s\n" % sub_count)
                        f_sub.write("%s --> %s\n" % (self.format_seconds(end-diff+second), self.format_seconds(end-diff+second+1)))
                        f_sub.write("Werbung #%i beginnt in %s Sekunden...\n\n" % (count + 1, str(diff - second)))

            f_edl.write("50000 0")
         
        error = cutlist.read_cuts()
                
        if error:
            self.__gui.message_error_box(error)
            return           

        self.__show(cutlist.cuts_seconds, video_filename, edl_subtitles_cb)            
    
    def show_cuts_after_cut(self, video_filename, cutlist):
        """ #FIXME """
        
        def edl_subtitles_cb(f_edl, f_sub, cuts):                    
            diff = self.config.get('general', 'pre_cut_show')
            pre_diff = self.config.get('general', 'after_cut_show')
                        
            length = 0
            sub_count = 0
                            
            for count, (start, duration) in enumerate(cuts):
                f_edl.write("%s %s 0\n" % (pre_diff + length, length + duration - diff))
                length += duration
                
                # vor dem schnitt:
                for second in range(diff):
                    sub_count += 1
                    f_sub.write("%s\n" % sub_count)
                    f_sub.write("%s --> %s\n" % (self.format_seconds(length - diff + second), self.format_seconds(length - diff + second + 1)))
                    if count == len(cuts) - 1:
                        f_sub.write("Sendung endet in %s Sekunden...\n\n" % str(diff - second))
                    else:
                        f_sub.write("Schnitt in %s Sekunden...\n\n" % str(diff - second))


        error = cutlist.read_cuts()
                
        if error:
            self.__gui.message_error_box(error)
            return           

        self.__show(cutlist.cuts_seconds, video_filename, edl_subtitles_cb)
    
    def format_seconds(self, seconds):
        """ #FIXME """
        
        hrs = seconds / 3600       
        leftover = seconds % 3600
        mins = leftover / 60
        secs = leftover % 60
        ms = int(seconds) - seconds
        
        return "%02d:%02d:%02d,%03d" % (hrs, mins, secs, ms)
                      
    def run(self):
        """ #FIXME """
        
        self.__gui.main_window.show()        

        if self.config.get('general', 'folder_new_otrkeys') == "":      
            self.__gui.message_info_box("Dies ist offenbar das erste Mal, dass OTR-Verwaltung gestartet wird.\n\nEs mÃ¼ssen zunÃ¤chst einige wichtige Einstellungen vorgenommen werden. Klicken Sie dazu auf OK.")
            self.__gui.preferences_window.show()
               
        self.__gui.run()
        
        # write to config
        self.config.set('general', 'planned_items', self.planned_broadcasts.get_config())               
        enabled, config = self.plugin_system.get_config()
        self.config.set('plugins', 'enabled', enabled)
        self.config.set('plugins', 'config', config)

        maximized = str(int(self.__gui.main_window.maximized))
        width = str(self.__gui.main_window.size[0])
        height = str(self.__gui.main_window.size[1])
        
        settings = ','.join([maximized, width, height])
        self.config.set('general', 'window_settings', settings)
 
if __name__ == '__main__':            
    app = App()
    app.run()
    app.config.save()

