#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os
from os.path import join, isdir, exists
import re
import subprocess
import time

try:
    from gtk import gdk
    import gobject
    if os.name == "posix":
        gdk.threads_init()    
except:
    print "PyGTK/GTK is missing."
    sys.exit(-1)


if exists(join(sys.path[0], 'otrpath.py')):    
    f = open(join(sys.path[0], 'conf'), 'a')
    f.close()
    filename = join(sys.path[0], 'log')
    
    import otrpath
    
    from log import Log
    log = Log(True, filename)
else:
    sys.path.insert(0, "/usr/share/otr-verwaltung")
    
    import otrpath
    filename = otrpath.get_config_path('log')

    from log import Log
    log = Log(False, filename)

log.l("Log file created at", filename)

# intern
from gui.gui import Gui
from actions import actions
from configparser import Config
import fileoperations
import cutlists as cutlists_management
from constants import Section, Action

class App:
    
    def __init__(self):             
        # read configs
        if exists(otrpath.get_path('conf')):
            self.config = Config(otrpath.get_path('conf'))
        else:
            self.config = Config(otrpath.get_config_path('conf'))

        self.__search_text = ""
            
        # regex
        self.__uncut_video = re.compile('.*_([0-9]{2}\.){2}([0-9]){2}_([0-9]){2}-([0-9]){2}_.*_([0-9])*_TVOON_DE.mpg\.(avi|HQ\.avi|mp4)$')
        self.__cut_video = re.compile('.*(avi|mp4)$') 
    
        # load gui
        self.__gui = Gui(self)
    
        # show undecoded otrkeys         
        self.section = Section.OTRKEY
        self.show_section(Section.OTRKEY)
        
        # compile list of planned items
        self.planned_broadcasts = []
        
        for item in self.config.get('planning', 'planned_items').split(';'):
            try:
                values = item.split(',')
                assert len(values) == 3
                
                self.planned_broadcasts += [(values[0], int(values[1]), values[2])]
            except:
                continue
        
        self.__gui.main_window.broadcasts_badge()
                                
    ### 
    ### Show sections
    ###
    
    def show_section(self, section):
        """ Shows one of the five different sections. 
            - set files of treeview
            - set section-variable to current section
            - set appropriate toolbar"""

        # set current section
        self.section = section
        
        # set toolbar
        self.__gui.main_window.set_toolbar(section)
                
        self.__gui.main_window.clear_files()
        files = []
        text = ""
        
        if section==Section.PLANNING:
            text = self.section_planning()
            self.__gui.main_window.show_planning(True)
        else:
            self.__gui.main_window.show_planning(False)
        
        if section==Section.OTRKEY:
            text, files = self.section_otrkey()
        
        elif section==Section.AVI_UNCUT:
            text, files = self.section_avi_uncut()   

        elif section==Section.AVI_CUT:
            text, files = self.section_avi_cut()   

        elif section==Section.TRASH:
            text, files = self.section_trash()   

        elif section==Section.ARCHIVE: 
            # returns NO files       
            text = self.section_archive()

        if len(files) > 0: # this is not executed when the section is "Archive"
            if len(files) == 1:
                text += " (1 Datei)"
            else:
                text += " (%s Dateien) " % len(files)
            
            files.sort() 
            
            # put filenames into treestore
            for f in files:
                # TODO: don't show files if in use
                self.append_row_treeview_files(None, f)

        # set message text
        self.__gui.main_window.get_widget('labelMessage').set_text(text)


    # helper for different sections
    def section_planning(self):
        text = "Diese Aufnahmen wurden geplant." 
       
        for count, broadcast in enumerate(self.planned_broadcasts):
            if self.search(broadcast[0]):
                self.__gui.main_window.append_row_planning(count)
            
        return text
             
    def section_otrkey(self):
        text = "Diese Dateien wurden noch nicht dekodiert." 
        path = self.config.get('folders', 'new_otrkeys')
        
        if path == "":      
            return text, []
        
        files = [join(path, f) for f in os.listdir(path) if f.endswith(".otrkey") and self.search(f)]                           
            
        return (text, files)
         
    def section_avi_uncut(self):
        text = "Diese Dateien wurden noch nicht geschnitten."
        path = self.config.get('folders', 'new_otrkeys')
        
        files = [join(path, f) for f in os.listdir(path) if self.__uncut_video.match(f) and self.search(f)]
            
        return (text, files)
        
    def section_avi_cut(self):
        text = "Diese avi-Dateien sind fertig geschnitten."
        if self.config.get('common', 'use_archive'):
            text += " Sie können ins Archiv verschoben werden."
                
        path = self.config.get('folders', 'new_otrkeys')
        
        files = []                
        for f in os.listdir(path):
            if not self.__uncut_video.match(f):
                if self.__cut_video.match(f):
                    if self.search(f):
                        files += [join(path, f)]
        
        return (text, files)
        
    def section_trash(self):
        text = "Diese otrkey- und avi-Dateien wurden bereits dekodiert bzw. geschnitten. Sie können normalerweise gelöscht werden."
        path = self.config.get('folders', 'trash')
                    
        files = [join(path, f) for f in os.listdir(path) if (f.endswith('.otrkey') or f.endswith('.avi')) and self.search(f)]
                
        return (text, files)

    def section_archive(self):
        text = "Diese Dateien wurden ins Archiv verschoben."

        path = self.config.get('folders', 'archive')
        
        self.tree(None, path)        
        
        return text            
                 
    # recursive function for archive to add folders and files with a tree structure
    def tree(self, parent=None, path=None):              
        if parent != None:            
            dir = self.__gui.main_window.get_widget('treeview_files').get_model().get_value(parent, 0)
        else:  # base path (archive directory)
            dir = path

        files = []
        files = os.listdir(dir)            

        for file in files:
            full_path = join(dir, file)
            
            if isdir(full_path):                
                iter = self.append_row_treeview_files(parent, full_path)
                self.tree(iter)
            else:
                if file.endswith('.avi'):
                    if self.search(file):
                        self.append_row_treeview_files(parent, full_path)

    ###
    ### Helpers
    ###
    
    def rename_by_schema(self, filename, schema=""):   
        if schema == "":
            schema = self.config.get('rename', 'schema')        
        
        if self.__uncut_video.match(filename):           
            
            parts = filename.split('_')
            parts.reverse()

            titel_list = parts[6:len(parts)]
            titel_list.reverse()
            titel = " ".join(titel_list)
            titel_mit = "_".join(titel_list)

            stunde, minute = parts[4].split('-')
            jahr, monat, tag = parts[5].split('.')           
            monatsname = time.strptime(monat, '%m')
            monatsname = time.strftime('%B', monatsname)

            sender_gross = parts[3].capitalize()

            format = parts[0]
            mp4 = False
            
            if 'HQ' in format:
                format = 'HQ'                
            elif 'mp4' in format:
                format = 'mp4'
                mp4 = True
            else:
                format = 'avi'

            values = {
                'titel' : titel,
                'titel_' : titel_mit,
                'sender' : parts[3],
                'SENDER': sender_gross,
                'tag': tag,
                'monat': monat,
                'MONAT': monatsname,
                'jahr': jahr,
                'stunde': stunde,
                'minute': minute,
                'dauer' : parts[2],
                'format' : format
            }
             
            for token, value in values.iteritems():
                schema = schema.replace('{%s}' % token, value)
                 
            if mp4 == True:
                schema += ".mp4"
            else:
                schema += ".avi"                   
                
            return schema
        else:         
            return filename
     
    def append_row_treeview_files(self, parent, filename):        
        iter = self.__gui.main_window.append_row_files(parent, filename, fileoperations.get_size(filename), fileoperations.get_date(filename))
        return iter
     
    
    ### 
    ### Search
    ### 
                      
    def start_search(self, search):
        self.__search_text = search.lower()

        items = []        
        # create dict of counts
        counts = {}

        for method, section in [(self.section_otrkey, Section.OTRKEY),
                                (self.section_avi_uncut, Section.AVI_UNCUT),
                                (self.section_avi_cut, Section.AVI_CUT),
                                (self.section_trash, Section.TRASH)]:
            files = []
            text, items = method()   
            count = len(items)
            if count > 0:
                counts[section] = "(%s)" % count
            else:
                counts[section] = ""
         
        # archive 
        files = []       
        for root, dirs, wfiles in os.walk(self.config.get('folders', 'archive')):
            for f in wfiles:
                # TODO: match all videos files
                if f.endswith('.avi') and self.search(f):
                    files += [join(root, f)]

        count = len(files)
        if count > 0:
            counts[Section.ARCHIVE] = "(%s)" % count
        else:
            counts[Section.ARCHIVE] = ""

        # planning
        items = []
        for count, broadcast in enumerate(self.planned_broadcasts):
            if self.search(broadcast[0]):
                items += [count]

        count = len(items)
        if count > 0:
            counts[Section.PLANNING] = "(%s)" % count
        else:
            counts[Section.PLANNING] = ""
        
        self.show_section(self.section)                   
        return counts
    
    def stop_search(self):
        self.__search_text = ""
        self.show_section(self.section)
        
    def search(self, f):
        if self.__search_text == "":
            return True
        else:    
            if self.__search_text in f.lower():
                return True
            else:
                return False
        
    ###
    ### Actions
    ###        
    
    def perform_action(self, chosen_action, filenames=None, broadcasts=None):
        """ Performs an action (toolbar, context menu, etc.) """

        if broadcasts != None and chosen_action in [Action.PLAN_EDIT, Action.PLAN_SEARCH, Action.PLAN_REMOVE, Action.PLAN_ADD]:
            if len(broadcasts) == 0 and chosen_action != Action.PLAN_ADD:
                self.__gui.message_info_box("Es ist keine Sendung markiert!")   
                return

        elif filenames != None:
            if len(filenames) == 0 and chosen_action != Action.NEW_FOLDER:
                self.__gui.message_info_box("Es ist keine Datei markiert!")     
                return           
           
        action = actions.get_action(chosen_action, self.__gui)            
               
        # different actions:
        if chosen_action in [Action.DECODE, Action.CUT, Action.DECODEANDCUT]: action.do(chosen_action, filenames, self.config, self.rename_by_schema)
        elif chosen_action == Action.RENAME: action.do(filenames)
        elif chosen_action == Action.REAL_DELETE: action.do(filenames)
        elif chosen_action == Action.RESTORE: action.do(filenames, self.config.get('folders', 'new_otrkeys'))
        elif chosen_action == Action.DELETE: action.do(filenames, self.config.get('folders', 'trash'))
        elif chosen_action == Action.PLAY: action.do(filenames[0], self.config.get('play', 'player'))
        elif chosen_action == Action.CUT_PLAY: action.do(filenames[0], self.config.get('play', 'mplayer'), self.config.get('folders', 'new_otrkeys'), self.config.get('cut', 'server'), self.config.get('cut', 'delete_cutlists'))            
        elif chosen_action == Action.PLAN_REMOVE: action.do(broadcasts, self.planned_broadcasts) 
        elif chosen_action == Action.PLAN_SEARCH: action.do(broadcasts, self.planned_broadcasts)            
        elif chosen_action == Action.PLAN_ADD: action.do(self.planned_broadcasts)
        elif chosen_action == Action.PLAN_EDIT: action.do(broadcasts[0], self.planned_broadcasts)        
        elif chosen_action == Action.ARCHIVE: action.do(filenames, self.config.get('folders', 'archive'))
        elif chosen_action == Action.NEW_FOLDER:
            if len(filenames) == 0:
                action.do(self.config.get('folders', 'archive'))
            else:
                action.do(filenames[0])
        
        # update view?
        if action.update_list:            
            self.__gui.main_window.do_search(self.__search_text)
            self.show_section(self.section)
            
     
    def show_cuts(self, avi_filename, cutlist_filename):
        cuts = cutlists_management.get_cuts_of_cutlist(cutlist_filename)

        if type(cuts) != list: # error occured
            self.__gui.message_error_box(cuts)
            return
            
        diff = 5
        
        f_edl = open(join(self.config.get('folders', 'new_otrkeys'), ".tmp.edl"), "w")
        f_sub = open(join(self.config.get('folders', 'new_otrkeys'), ".tmp.sub"), "w")

        #     Start          Duration
        # 0  286.177737     631.462533
        # 1  1452.4505715   528.5813674

        # 0 283.24 0
        # 289.24 914.6 0
        # 920.6 1449.12 0
        # 1455.12 1977.84 0
        # 1983.84 50000 0

        # 1
        # 00:00:10,000 --> 00:00:11,000
        # Noch 5 Sekunden

        sub_count = 0

        f_edl.write("0 ")
        

        for count, start, duration in cuts:
            end = start + duration

            f_edl.write("%s 0\n" % (start - diff))
            f_edl.write("%s %s 0\n" % (start + diff, end - diff))
            f_edl.write("%s " % (end + diff))

            for second in range(diff):
                sub_count += 1
                f_sub.write("%s\n" % sub_count)
                f_sub.write("%s --> %s\n" % (self.format_seconds(start-diff+second), self.format_seconds(start-diff+second+1)))
                f_sub.write("Noch %s Sekunden...\n\n" % str(diff - second))            
                
            for second in range(diff):
                sub_count += 1
                f_sub.write("%s\n" % sub_count)
                f_sub.write("%s --> %s\n" % (self.format_seconds(end-diff+second), self.format_seconds(end-diff+second+1)))
                f_sub.write("Noch %s Sekunden...\n\n" % str(diff - second))
            
        f_edl.write("50000 0")
        
        f_edl.close()
        f_sub.close()
            
        p = subprocess.Popen([self.config.get('play', 'mplayer'), "-edl", join(self.config.get('folders', 'new_otrkeys'), ".tmp.edl"), "-sub", join(self.config.get('folders', 'new_otrkeys'), ".tmp.sub"), avi_filename])
    
    def format_seconds(self, seconds):
        hrs = seconds / 3600       
        leftover = seconds % 3600
        mins = leftover / 60
        secs = leftover % 60
        ms = int(seconds) - seconds
        
        return "%02d:%02d:%02d,%03d" % (hrs, mins, secs, ms)
            
          
    def run(self):
        self.__gui.main_window.show()      

        if self.config.get('folders', 'new_otrkeys') == "":      
            self.__gui.message_info_box("Dies ist offenbar das erste Mal, dass OTR-Verwaltung gestartet wird.\n\nEs müssen zunächst einige wichtige Einstellungen vorgenommen werden. Klicken Sie dazu auf OK.")
            self.__gui.preferences_window.show()
               
        self.__gui.run()
        
        # write planning to config
        string = ''
        for broadcast in self.planned_broadcasts:
            string += broadcast[0] + ',' + str(broadcast[1]) + ',' + broadcast[2] + ';'
        self.config.set('planning', 'planned_items', string)               

             
app = App()
app.run()
app.config.save()
